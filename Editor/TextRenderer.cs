using System.Collections;
using System.Collections.Generic;
using System.Text;
using UnityEngine;
using Unity.Mathematics;
using Unity.Jobs;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using UnityEngine.UIElements;
using UnityEngine.TextCore.Text;
using UnityEditor;
using UnityEngine.TextCore.LowLevel;
using UnityEditorInternal;
using Unity.Burst;
using static Unity.Burst.Intrinsics.X86;
using static Unity.Burst.Intrinsics.X86.Sse;
using static Unity.Burst.Intrinsics.X86.Sse2;
using static Unity.Burst.Intrinsics.Arm.Neon;
using Unity.Burst.Intrinsics;
using System;
using UnityEngine.Rendering;
using System.Diagnostics;

/// <summary>
/// Generated by the pre-pass for the CalculateLabelsJob. Contains info of the events that should show text.
/// </summary>
internal struct VisibleText
{
    /// Key used for lookup into the global lable table
    internal ulong key;
    /// New position for the text
    internal float2 pos;
    /// String ID
    internal int markerId;
    /// Width of the text to be displayed
    internal float width;
    /// Time in miliseconds for this sample
    internal float timeMs;
    /// Category of the event
    internal ushort categoryId;
    /// Alpha value used for calculating the color (0 - 255)
    internal byte alpha;
    /// Index into frameInfo table
    internal byte frameInfoIndex;
}

/// <summary>
/// This represent a text position to be rendered with index to the original RawData
/// </summary>
internal struct TimelineText
{
    /// New position for the text
    internal float2 pos;
    /// Color of the text
    internal Color color;
    /// Index into the array of frames we are working with
    internal int frameIndex;
    /// String ID
    internal int markerId;
    /// Width of the text to be displayed
    internal float width;
    /// Time in miliseconds for this sample
    internal float timeMs;
}

enum UpdateType
{
    // No update is required
    Hidden = 0,
    // Update position of the element only
    Position = 1,
    // Text and Position Update
    TextPos = 2,
}

internal class MathUtils
{
    internal enum ThreadVisibility
    {
        Hidden,
        Partial,
        Fully,
    }
    static internal ThreadVisibility CalcThreadVisibility(float screenStartY, float screenEndY, float startY, float endY)
    {
        if (endY < screenStartY || startY > screenEndY) {
            return ThreadVisibility.Hidden;
        } else if (startY >= screenStartY && endY <= screenEndY) {
            return ThreadVisibility.Fully;
        } else {
            return ThreadVisibility.Partial;
        }
    }
}

/// <summary>
/// Calculates which text that is visible for a frame.
/// </summary>

[BurstCompile()]
internal struct CalculateVisibleLabel : IJob
{
    const float k_BorderSize = 2.0f;
    internal const int kBatchCount = 32;
    [ReadOnly]
    internal NativeList<ProfilingEvent> m_events;
    /// FrameSelectorSettings for generating the timeline (such as zooming matrix, screensize etc)
    [ReadOnly]
    internal TimelineSettings m_settings;
    /// FrameIndex and some more info
    [ReadOnly]
    internal FrameIndex m_frameIndex;
    [ReadOnly]
    internal NativeHashMap<ulong, ThreadPosition> m_threadOffsets;
    [ReadOnly]
    internal NativeArray<ThreadInfo> m_threads;
    [ReadOnly]
    internal JobSelection m_jobSelection;
    /// Active filters
    [ReadOnly]
    internal NativeHashSet<int> m_idFilters;
    /// Set to true if filter is enabled.
    [ReadOnly]
    internal bool m_useFilter;
    [ReadOnly]
    internal byte m_frameInfoIndex;
    /// Output
    [WriteOnly]
    internal NativeList<VisibleText> m_output;

    void ProcessThread(ThreadInfo threadInfo, float threadOffset)
    {
        float2 scale = new float2(m_settings.mat.c0.x, m_settings.mat.c1.y);
        float2 trans = new float2(m_settings.mat.c3.x, m_settings.mat.c3.y);

        for (int eventIndex = threadInfo.eventStart; eventIndex < threadInfo.eventEnd; ++eventIndex)
        {
            ProfilingEvent profEvent = m_events[eventIndex];

            float2 posLocal = new float2(profEvent.startTime + m_frameIndex.time, threadOffset + profEvent.level);
            float2 sizeLocal = new float2(profEvent.time, m_settings.invYBarSize);
            float2 cornerLocal = posLocal + sizeLocal;

            float2 pos = (posLocal * scale) + trans;
            float2 corner = (cornerLocal * scale) + trans;
            float2 size = corner - pos;

            Rect barRect = new Rect(pos.x, pos.y, size.x, size.y);

            const float kMinSize = 32.0f;
            const float kMinFadedSize = 4.0f;

            // Make sure the bar is within the window otherwise we skip render it
            if (size.x < kMinSize || !m_settings.windowRect.Overlaps(barRect))
                continue;

            if (m_useFilter && !m_idFilters.Contains(profEvent.markerId))
                continue;

            // If we have a position that is outside the window we clamp it to zero and see if we still have
            // some text to render and also adjust the size
            if (pos.x < 0.0f)
            {
                // Skip if the bar is outside the window
                if (corner.x - pos.x < kMinSize)
                    continue;

                size.x = corner.x;

                // If the text is smaller than 4 pixels we will skip it as it's already faded out fully
                if (size.x < kMinFadedSize)
                    continue;

                pos.x = 0.0f;
            }

            float alpha = math.clamp((size.x - kMinSize) * 1.0f / 64.0f, 0.0f, 1.0f);

            if (m_jobSelection.state == JobSelection.State.Selected)
            {
                if ((m_frameIndex.frameCacheIndex != m_jobSelection.frameIndex) || (m_jobSelection.eventIndex != eventIndex))
                    alpha *= 0.5f;
            }

            ulong key = (((ulong)m_frameIndex.frameCacheIndex) << 32) | (ulong)(uint)eventIndex;

            var output  = new VisibleText
            {
                key = key,
                pos = new float2(pos.x + k_BorderSize, pos.y + k_BorderSize),
                categoryId = profEvent.categoryId,
                alpha = (byte)(alpha * 255.0f),
                markerId = profEvent.markerId,
                width = size.x - (k_BorderSize * 2),
                timeMs = profEvent.time,
                frameInfoIndex = m_frameInfoIndex,
            };

            m_output.Add(output);
        }
    }

    public void Execute()
    {
        float screenStartY = m_settings.windowRect.y;
        float screenEndY = screenStartY + m_settings.windowRect.height;
        float trans = m_settings.mat.c3.y;
        float scale = m_settings.mat.c1.y;

        foreach (var thread in m_threads)
        {
            ThreadPosition threadPos;

            if (m_threadOffsets.TryGetValue(thread.threadId, out threadPos))
            {
                float startY = (threadPos.offset * scale) + trans;
                float endY = startY + ((threadPos.offset + threadPos.depth) * scale);

                if (MathUtils.CalcThreadVisibility(screenStartY, screenEndY, startY, endY) == MathUtils.ThreadVisibility.Hidden)
                    continue;

                ProcessThread(thread, threadPos.offset);
            }
        }
    }
}


/// <summary>
/// Calculates TextElement placements and usage. This code is resposible to minimize the text updates
/// needed to the TextElement as it's a costly operation.
/// </summary>
[BurstCompile()]
internal struct CalculateLabelUpdatesJob : IJob
{
    /// Profiling Events
    [ReadOnly]
    internal NativeList<VisibleText> m_events;
    /// List of positions, widths, etc that is needed for the TextElements
    [WriteOnly]
    internal NativeArray<TimelineText> m_timelineText;
    /// Current frame
    [ReadOnly]
    internal uint m_updateFrame;
    // Info about each frame being processed. Used as lookup to save some memory
    [ReadOnly]
    internal NativeArray<FrameIndex> m_frameIndices;

    [WriteOnly]
    internal NativeArray<byte> m_updateIndices;
    /// HashMap to that is used to figure out if an event is active or not
    /// The key is constructed of the frameId + eventIndex (as these are unqiue)
    internal NativeHashMap<ulong, int> m_labelLookup;
    /// For the above table lookup this table shows at which frame something
    /// is visible. This is used to figure which slots that should be re-used
    /// as the oldest ones are being used.
    internal NativeArray<uint> m_frameCounts;
    /// This allows us to check if we have a key to remove when allocating a new slot
    internal NativeArray<ulong> m_lookupKeys;

    /// This code will in a linear fashion finds the lowest frame count number.
    /// As this code just tries to find in a linear fashion it needs to be pretty fast
    /// and the assumtion is made that this list isn't extremly long. At the time of
    /// writing the frameCounts array is 512 entries and as we do a unrolled SSE/NEON
    /// loop here and check 64 entries each loop it should be pretty fast.
    int FindSmallestIndex(uint frameIndex)
    {
        /*
        if (IsSse2Supported)
        {
            v128 increment = set1_epi16(8);
            v128 indices = setr_epi16(0, 1, 2, 3, 4, 5, 6, 7);
            v128 minvalues = set1_epi16(frameIndex);
            v128 minindices = indices;

            for (int i = 0, count = frameCounts.Length; i < count; i += 64)
            {
                v128 v0 = frameCounts.ReinterpretLoad<v128>(i + 0);
                v128 v1 = frameCounts.ReinterpretLoad<v128>(i + 16);
                v128 v2 = frameCounts.ReinterpretLoad<v128>(i + 32);
                v128 v3 = frameCounts.ReinterpretLoad<v128>(i + 48);

                v128 lt0 = cmplt_epi16(v0, minvalues);
                minindices = or_si128(and_si128(v0, lt0), andnot_si128(lt0, minindices));
                minvalues = min_epi16(minvalues, v0);
                indices = add_epi16(indices, increment);

                v128 lt1 = cmplt_epi16(v1, minvalues);
                minindices = or_si128(and_si128(v1, lt1), andnot_si128(lt1, minindices));
                minvalues = min_epi16(minvalues, v1);
                indices = add_epi16(indices, increment);

                v128 lt2 = cmplt_epi16(v2, minvalues);
                minindices = or_si128(and_si128(v2, lt2), andnot_si128(lt2, minindices));
                minvalues = min_epi16(minvalues, v2);
                indices = add_epi16(indices, increment);

                v128 lt3 = cmplt_epi16(v3, minvalues);
                minindices = or_si128(and_si128(v3, lt3), andnot_si128(lt3, minindices));
                minvalues = min_epi16(minvalues, v3);
                indices = add_epi16(indices, increment);
            }

            tempValues.ReinterpretStore<v128>(0, minvalues);
            tempIndices.ReinterpretStore<v128>(0, minindices);

            // find the actual min value and index value

            short v = tempValues[0];
            short index = tempIndices[0];

            for (int i = 1; i < 8; ++i)
            {
                if (v < tempValues[i])
                {
                    v = tempValues[i];
                    index = tempIndices[i];
                }
            }

            return index;
        }
        //else if (IsNeonArmv82FeaturesSupported)
        else if (false)
        {

        }
        else
        */
        {
            int foundIndex = 0;

            for (int i = 0, count = m_frameCounts.Length; i < count; ++i)
            {
                uint v = m_frameCounts[i];

                if (v < frameIndex)
                {
                    frameIndex = v;
                    foundIndex = i;
                }
            }

            return foundIndex;
        }
    }
    public void Execute()
    {
        foreach (var textInfo in m_events)
        {
            ulong key = textInfo.key;
            int index = 0;

            // Check if we already have
            if (m_labelLookup.TryGetValue(key, out index))
            {
                // Update the index with the current frame
                m_updateIndices[index] = (byte)UpdateType.Position;
            }
            else
            {
                index = FindSmallestIndex(m_updateFrame);

                // Remove existing key (this call will fail if no key exists, but that is fine)
                m_labelLookup.Remove(m_lookupKeys[index]);

                m_updateIndices[index] = (byte)UpdateType.TextPos;
                m_lookupKeys[index] = key;
                m_labelLookup.TryAdd(key, index);
            }

            FrameIndex frameIndex = m_frameIndices[textInfo.frameInfoIndex];

            float alpha = textInfo.alpha * 1.0f / 255.0f;
            float fade = frameIndex.fade;

            Color startColor = Color.white;
            Color endColor = Color.black;

            if (textInfo.categoryId == 3)
                startColor = new Color(0.2f, 0.2f, 0.2f, 1.0f);

            startColor.a = alpha;
            endColor.a = alpha;

            Color textColor = Color.Lerp(startColor, endColor, fade);

            m_frameCounts[index] = m_updateFrame;
            m_timelineText[index] = new TimelineText
            {
                pos = textInfo.pos,
                color = textColor,
                frameIndex = frameIndex.frameCacheIndex,
                markerId = textInfo.markerId,
                width = textInfo.width,
                timeMs = textInfo.timeMs,
            };
        }
    }
}

internal class WrapText : VisualElement
{
    internal Label m_text;

    internal WrapText()
    {
        m_text = new Label();
        usageHints = UsageHints.DynamicTransform;
        style.overflow = Overflow.Hidden;
        style.position = Position.Absolute;
        style.transformOrigin = new TransformOrigin(0, 0);

        //style.justifyContent = Justify.Center;
        //m_text.style.overflow = Overflow.Hidden;
        //m_text.style.textOverflow = TextOverflow.Clip;
        //m_text.style.whiteSpace = WhiteSpace.NoWrap;
        //m_text.style.unityTextAlign = TextAnchor.MiddleCenter;
        m_text.usageHints = UsageHints.DynamicTransform;

        //style.position = Position.Absolute;

        Add(m_text);
    }

    internal void SetScale(float scale)
    {
        style.scale = new Scale(new Vector3(scale, 1, 1));
    }

    internal void SetTranslate(float2 pos)
    {
        style.translate = new Translate(pos.x, pos.y);
    }
}

internal class TextRenderer
{
    internal const float kSkipTextBarSize = 14.0f;

    NativeArray<byte> m_updateIndices;
    NativeList<VisibleText> m_visibleTexts;
    NativeArray<TimelineText> m_timelineTexts;
    NativeHashMap<ulong, int> m_labelLookup;
    /// For the above table lookup this table shows at which frame something
    /// is visible. This is used to figure which slots that should be re-used
    /// as the oldest ones are being used.
    NativeArray<uint> m_frameCounts;
    /// This allows us to check if we have a key to remove when allocating a new slot
    NativeArray<ulong> m_lookupKeys;
    List<WrapText> m_barLabels;
    int m_currentFrame = 0;

    // Number of cache text elements. Needs to even diviable by 32
    const int k_CacheTextElements = 1024;

    internal TextRenderer()
    {
        m_updateIndices = new NativeArray<byte>(k_CacheTextElements, Allocator.Persistent);
        m_timelineTexts = new NativeArray<TimelineText>(k_CacheTextElements, Allocator.Persistent);
        m_labelLookup = new NativeHashMap<ulong, int>(k_CacheTextElements, Allocator.Persistent);
        m_frameCounts = new NativeArray<uint>(k_CacheTextElements, Allocator.Persistent);
        m_lookupKeys = new NativeArray<ulong>(k_CacheTextElements, Allocator.Persistent);
        m_barLabels = new List<WrapText>(k_CacheTextElements);
        m_visibleTexts = new NativeList<VisibleText>(k_CacheTextElements, Allocator.Persistent);

        for (int i = 0; i < k_CacheTextElements; ++i)
        {
            var element = new WrapText();
            m_barLabels.Add(element);
        }
    }
    internal void LinkTextElements(VisualElement parent)
    {
        foreach (var barLabel in m_barLabels)
            parent.Add(barLabel);
    }

    internal void PreUpdate()
    {
        m_visibleTexts.Clear();

        for (int i = 0; i < k_CacheTextElements; ++i)
            m_updateIndices[i] = 0;
    }

    internal JobHandle ScheduleJob(
        byte frameInfoIndex,
        TimelineSettings settings,
        NativeHashMap<ulong, ThreadPosition> threadOffsets,
        NativeHashSet<int> idFilters,
        FrameDataIndex frameInfo,
        JobSelection jobSelection,
        JobHandle dependency)
    {
        var frame = frameInfo.data;

        var job = new CalculateVisibleLabel
        {
            m_events = frame.events,
            m_settings = settings,
            m_frameIndex = frameInfo.index,
            m_jobSelection = jobSelection,
            m_idFilters = idFilters,
            m_useFilter = idFilters.Count > 0,
            m_threadOffsets = threadOffsets,
            m_threads = frame.threads,
            m_output = m_visibleTexts,
            m_frameInfoIndex = frameInfoIndex,
        };

        return job.Schedule(dependency);
    }

    internal void PostUpdate(JobHandle prevHandle, in NativeArray<FrameIndex> frameIndices, in FrameCache frameCache)
    {
        var labelsJob = new CalculateLabelUpdatesJob
        {
            m_events = m_visibleTexts,
            m_frameIndices = frameIndices,
            m_updateFrame = (uint)m_currentFrame,
            m_timelineText = m_timelineTexts,
            m_updateIndices = m_updateIndices,
            m_labelLookup = m_labelLookup,
            m_frameCounts = m_frameCounts,
            m_lookupKeys = m_lookupKeys,
        };

        labelsJob.Schedule(prevHandle).Complete();

        StringBuilder sb = new StringBuilder(512);

        for (int i = 0, count = m_updateIndices.Length; i < count; ++i)
        {
            UpdateType updateState = (UpdateType)m_updateIndices[i];

            if (updateState == UpdateType.Hidden)
            {
                m_barLabels[i].visible = false;
            }
            else
            {
                var info = m_timelineTexts[i];
                m_barLabels[i].SetTranslate(info.pos);

                m_barLabels[i].style.width = info.width;
                m_barLabels[i].style.opacity = 1;
                m_barLabels[i].visible = true;
                m_barLabels[i].style.color = info.color;

                if (updateState == UpdateType.TextPos)
                {
                    string name = frameCache.GetStringForFrame(info.frameIndex, info.markerId);
                    sb.AppendFormat("{0} ({1:F4} ms)", name, info.timeMs);
                    m_barLabels[i].m_text.text = sb.ToString();
                    sb.Clear();
                }
            }
        }

        m_currentFrame++;
    }

    /*
    internal void ClearLabelCache()
    {
        m_labelLookup.Clear();

        for (int i = 0; i < m_lookupKeys.Length; ++i)
            m_lookupKeys[i] = 0;
    }
    */

    internal void HideLables()
    {
        foreach (var label in m_barLabels)
            label.visible = false;
    }

    ~TextRenderer()
    {
        m_timelineTexts.Dispose();
        m_labelLookup.Dispose();
        m_frameCounts.Dispose();
        m_lookupKeys.Dispose();
        m_updateIndices.Dispose();
        m_visibleTexts.Dispose();
    }
}
